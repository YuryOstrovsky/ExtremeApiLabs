<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lab XIQ-C Environment</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>
    <style>
        pre {
            background-color: #000;
            color: #fff;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            position: relative;
        }
	.copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background-color: #3f3f3f;
            color: #ccc;
            border: none;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>Lab XIQ-C Environment</h1>
    <p>For the LAB purposes we will be using following XIQ-C and credentials:</p>
    <ul>
	    <li>URL: <a href="https://xca.plm.extremewireless.ca:5825" target="_blank"> https://xca.plm.extremewireless.ca:5825</a></li>
        <li>User: readonly</li>
        <li>Password: Extreme!</li>
    </ul>

    <h1> LAB1. API Token. </h1>
    <h2>Importing modules</h2>
    <p>At the very beginning of the script, you would need to import at least 2 modules: <code>requests</code> and <code>json</code>.</p>
    <p><strong>Requests</strong> is a HTTP library written in PHP, for human beings. It is roughly based on the API from the excellent Requests Python library. Requests al lows you to send HEAD, GET, POST, PUT, DELETE, and PATCH HTTP requests. You can add headers, form data, multipart files, and parameters with simple arrays, and access the response data in the same way. JSON will let you turn JSON formatted strings to python dictionaries, and vice versa.</p>
    <p>To import a module in python on a single line you write <code>import &lt;module_name&gt;</code>. For our purposes the first two lines of your script should look like this:</p
>
    <pre><code id="import-modules">import requests
import json
</code><button class="copy-btn" data-clipboard-target="#import-modules">Copy code</button></pre>

    <h2>Authorization and first request</h2>
    <p>Most API calls to the XIQ-C expect that you will pass a token in the header that signifies that you are who you say you are.</p>
    <p>The API provides a way to get this token: you need to do a POST request to <code>/management/v1/oauth2/token</code> with your username and password.</p>
    <p>Lets see in details how to build this request.</p>
    <p>A POST (using requests module) will look similar to the following:</p>
    <pre><code id="authorization-request">r = requests.post(&lt;url&gt;, json=&lt;request_body&gt;, headers=&lt;request_headers&gt;, verify=False)
</code><button class="copy-btn" data-clipboard-target="#authorization-request">Copy code</button></pre>

    <p><strong>Where:</strong></p>
    <ul>
        <li><code>&lt;url&gt;</code>: is the full URL of the API endpoint we want to talk to. It will be something like that: <code>https://xca.plm.extremewireless.ca:5825
/managemen
t/v1/oauth2/token</code></li>
        <li><code>&lt;request_body&gt;</code>: the body of the HTTP request; in a case of obtaining a token, that is where we want to put our username and password. The HTTP request itself will have this in JSON format, but here we can use a Python dictionary and <code>requests</code> module will transform it for us.</li>
        <li><code>&lt;request_headers&gt;</code>: the headers of the HTTP request; if you are accessing some other API this is where you would put your access token, and things like what format you expect the API to respond in, and what format you are sending it data in. For this request we need no headers, so all of <code>headers=&lt;request_headers
&gt;</code
>, can be omitted entirely.</li>
        <li><code>verify=False</code>: since we are sending requests using HTTPS, <code>requests</code> module will expect the XIQ-C to have a certificate signed by one of the root CA (public or private). We did not bother installing any valid certificate to XIQ-C in our lab. To skip the certificate validation, we would need to set this option to False.</li>
    </ul>

    <p>This method call will return an object representing the response we got from the API, so the <code>r =</code> at the beginning is to throw that into a variable so we can actu ally do something with our token.</p>

    <p>The request body for this request should look like this:</p>
    <pre><code id="request-body">body = {"grantType": "password", "userId": "readonly", "password": "Extreme!", "scope":"myScope"}
</code><button class="copy-btn" data-clipboard-target="#request-body">Copy code</button></pre>

    <p><code>data</code> is the variable we will pass to <code>json</code> in our POST. This request requires no special headers, any standard ones will be automatically m
ade for us
.</p>

    <p>Now you have all the bits and pieces, let’s make a POST (replace with your IP and credentials):</p>
    <pre><code id="make-post-request">r = requests.post("https://xca.plm.extremewireless.ca:5825/management/v1/oauth2/token", json=body, verify=False)
</code><button class="copy-btn" data-clipboard-target="#make-post-request">Copy code</button></pre>

    <p><strong><code>'r'</code></strong> contains the response from the API; we can access few things for troubleshooting and debugging here:</p>

    <p><strong><code>'r.headers'</code></strong> - a python dictionary with all the headers of the response, things like body data format, </p>
	<p><strong><code>r.content'</code></strong> - the body of the response, if you send a GET this is probably what you were looking for.</p>


    <p>Let’s grab the body of the response, and use json module to convert it into a python object:</p>

    <pre><code id="parse-response">content = json.loads(r.content)
</code><button class="copy-btn" data-clipboard-target="#parse-response">Copy code</button></pre>

    <p>Get the <code>access_token</code> field from the object (“content”) you just made:</p>

    <pre><code id="get-access-token">auth_t = content["access_token"]
</code><button class="copy-btn" data-clipboard-target="#get-access-token">Copy code</button></pre>

    <p>Variable <code>auth_t</code> should now contain the token that will allow you to make authorized requests to all the other parts of the API, print it out with the following line to see what it looks like:</p>

    <pre><code id="print-token">print(auth_t)
</code><button class="copy-btn" data-clipboard-target="#print-token">Copy code</button></pre>

    <p>Your final script to obtain the token should look like that:</p>

    <pre><code id="final-script">import requests
import json

# Authorization and first request
url = "https://xca.plm.extremewireless.ca:5825/management/v1/oauth2/token"
body = {"grantType": "password", "userId": "readonly", "password": "Extreme!", "scope":"myScope"}
r = requests.post(url, json=body, verify=False)

# Parse response
content = json.loads(r.content)
auth_t = content["access_token"]

# Print token
print(auth_t)

</code><button class="copy-btn" data-clipboard-target="#final-script">Copy code</button></pre>

        <p>Together with the token you probably see some ugly warning regarding the absense of certificate. If you don't want to see this warning, you can add this two lines in your code : </p>

	<pre><code id="remove-warning"> import urllib3
 urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


</code><button class="copy-btn" data-clipboard-target="#remove-warning">Copy code</button></pre>	



<p>So your final code to get Authorization token will be like that :  </p>

        <pre><code id="auth-token"> import urllib3
 urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
 import requests
 import json

 # Authorization and first request
 url = "https://xca.plm.extremewireless.ca:5825/management/v1/oauth2/token"
 body = {"grantType": "password", "userId": "readonly", "password": "Extreme!", "scope":"myScope"}
 r = requests.post(url, json=body, verify=False)

 # Parse response
 content = json.loads(r.content)
 auth_t = content["access_token"]

 # Print token
 print(auth_t)




</code><button class="copy-btn" data-clipboard-target="#auth-token">Copy code</button></pre>

<h1> LAB2. GET-ing information from XIQ-C. </h1>
<p> Now since your script already able to obtain an API token we can build some userful API call.
The system security required that every API call to XIQ-C will need to be authenticated. Authentication is
usually passed into the request in it’s Header. The token (see Lab 1) will be used for authentication.
In this lab we will be getting the list of Roles available on your XIQ-C. You can apply the same technic to
any other GET requests to obtain any information from XIQ-C (such as list of sites , or Access points and so
on).</p>

<p>In this lab we will be using this API endpoint :
</p>
<a href="https://documentation.extremenetworks.com/XIQC/10.06/API/index_gateway_api.html#tag/RoleManager/paths/~1v3~1roles/get" target="_blank">Link to Extreme Networks API Documentation</a>
<p> </p>

<p> Let’s build the Header in the same way we build Request Body in the Lab 1. </p>


<pre><code id="headers">headers = {'Authorization': "Bearer " + auth_t.decode(),
'Content-Type': 'application/json',
'Accept': 'application/json'
}

</code><button class="copy-btn" data-clipboard-target="#headers">Copy code</button></pre>

<p>The <strong>`Authorization`</strong> field is the one we pass our token in; the XIQ-C expects it to be of the form “Bearer
<token>”, so we add “Bearer “ before our token.</p>

<p>The <strong>`Content-Type`</strong> field tells the API what format the body of your request is in: `application/json` is very
common and just means the body will be a JSON formatted string. Our request does not require a body but
this field is generally expected regardless.</p>

<p>The <strong>`Accept`</strong> field tells the API what data format we expect in the body of the response it sends back to us,
we also want to work with JSON so we set it to the same thing as the `Content-Type`.</p>

<p>We added <strong>.decode()</strong> to the <strong>auth_t</strong> ?
In Python 3, the requests library returns responses as byte strings (bytes) by default. When you decode these byte strings to regular strings using the decode() method, you convert them from their byte representation to a string representation, usually using a specific character encoding like UTF-8.

So, when you retrieve content from the response object (r.content), it's in bytes, and if you want to print it directly, you need to decode it to convert it into a readable string format. That's why you use decode() to convert bytes to strings before printing.
</p>

<p>Header is ready , now make the API call :
</p>

<pre><code id="request-get">r = requests.get("https://xca.plm.extremewireless.ca:5825/management/v3/roles", headers=headers, verify=False)
print(r.content)
</code><button class="copy-btn" data-clipboard-target="#request-get">Copy code</button></pre>

<p>Your script now looks like that :</p>

<pre><code id="request-get-script"> import urllib3
 urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
 import requests
 import json

 # Authorization and first request
 url = "https://xca.plm.extremewireless.ca:5825/management/v1/oauth2/token"
 body = {"grantType": "password", "userId": "readonly", "password": "Extreme!", "scope":"myScope"}
 r = requests.post(url, json=body, verify=False)

 r.status_code
 r.headers
 r.content


 # Parse response
 content = json.loads(r.content)
 auth_t = content["access_token"]

 # Print token - we don't want to print token any more, right? Lets comment this out. 
 #print(auth_t)

 # Creating API call to GET Roles from XIQ-C

 headers = {'Authorization':"Bearer "+ auth_t,
 	    'Content-Type':'application/json',
	    'Accept':'application/json'
	    }
r = requests.get("https://xca.plm.extremewireless.ca:5825/management/v3/roles",headers=headers, verify=False)
print(r.content)

</code><button class="copy-btn" data-clipboard-target="#request-get-script">Copy code</button></pre>

<p> You just executed it , right? Do you like the output ? Not really . It is somewhat readable , but you
probably want to see just roles , and maybe ID’s ?
Let’s tune it a bit.

Instead of <strong>print(r.content.decode())</strong> line , replace it with that something which make it cleaner :

<pre><code id="role-list">content = json.loads(r.content.decode())

for role in content:
    print(role["name"] + ":" + role["id"])
</code><button class="copy-btn" data-clipboard-target="#role-list">Copy code</button></pre>

<p> What we just did? We took the whole JSON payload and parsed it. Every string of JSON become a python
object (list in this case). Then we just use a loop (for) through this list and print out the names and matching IDs
of our roles.
Here is how the script looks like now:
</p>

<pre><code id="role-list-full"> import urllib3
 urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
 import requests
 import json

 # Authorization and first request
 url = "https://xca.plm.extremewireless.ca:5825/management/v1/oauth2/token"
 body = {"grantType": "password", "userId": "readonly", "password": "Extreme!", "scope":"myScope"}
 r = requests.post(url, json=body, verify=False)

 r.status_code
 r.headers
 r.content


 # Parse response
 content = json.loads(r.content)
 auth_t = content["access_token"]

 # Creating API call to GET Roles from XIQ-C

 headers = {'Authorization':"Bearer "+ auth_t,
 	    'Content-Type':'application/json',
	    'Accept':'application/json'
	    }
r = requests.get("https://xca.plm.extremewireless.ca:5825/management/v3/roles",headers=headers, verify=False)

content = json.loads(r.content)

for role in content:
    print(role["name"] + ":" + role["id"])
</code><button class="copy-btn" data-clipboard-target="#role-list-full">Copy code</button></pre>

<p>
Now , for example , you need to count how many roles you have in your system. Do you want to do it
manually (with your finger pointing to the screen and counting one-two-three…) ? Or would you prefer to use a
magic of programming and count it with python? 
Add this line to your script :
</p>

<pre><code id="count-roles">print("We have " + str(len(content)) + " roles")

</code><button class="copy-btn" data-clipboard-target="#count-roles">Copy code</button></pre>

<p>
We added str here becouse python does not know how to add words and numbers. So we converted the
number into a string.

Your scrip now looks like that :
</p>

<pre><code id="roles-with-count"> import urllib3
 urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
 import requests
 import json

 # Authorization and first request
 url = "https://xca.plm.extremewireless.ca:5825/management/v1/oauth2/token"
 body = {"grantType": "password", "userId": "readonly", "password": "Extreme!", "scope":"myScope"}
 r = requests.post(url, json=body, verify=False)

 r.status_code
 r.headers
 r.content


 # Parse response
 content = json.loads(r.content)
 auth_t = content["access_token"]

 # Creating API call to GET Roles from XIQ-C

 headers = {'Authorization':"Bearer "+ auth_t,
 	    'Content-Type':'application/json',
	    'Accept':'application/json'
	    }
r = requests.get("https://xca.plm.extremewireless.ca:5825/management/v3/roles",headers=headers, verify=False)

content = json.loads(r.content)

for role in content:
    print(role["name"] + ":" + role["id"])


print("We have " + str(len(content)) + " roles")



</code><button class="copy-btn" data-clipboard-target="#roles-with-count">Copy code</button></pre>

<h1> LAB3. PUT-ing information to XIQ-C</h1>

<div style="border: 2px solid #000; padding: 10px; background-color: #f0f0f0; border-radius: 5px;">
    <p style="font-weight: bold; color: #000;">NOTE: This LAB requires some write-access to the system which is not possible with the offered XIQ-C. You can use the same environment of Jupyter Notebook, but you have to direct requests to your own XIQ-C.</p>
    <p>In this lab, please replace &lt;your_own_XIQ-C&gt; with the IP address or hostname of your controller. Also, make sure your user has write access permission to your controller.</p>
</div>

<p> Now lets do some configuration changes on XIQ-C via API.
We will be using this API endpoint in the lab :
</p>

<a href="https://documentation.extremenetworks.com/XIQC/10.06/API/index_gateway_api.html#tag/RoleManager/paths/~1v3~1roles/post" target="_blank">Link to Extreme Networks API Documentation</a>

<p>The way modification works with the XIQ-C REST API is that it expects you to send the entire object with all the
changes; you can’t only send the parts you care about. So the way to modify something is to first GET the existing
object, modify whatever you want, then PUT it back in.
</p>

<p>Look through the output from the last step of LAB2, you should see that each role has a field called “id”; this is
what the API wants to know if you ask it for a specific role, so if we want to get the info for only one of our
roles, we would use this endpoint: </p>

<a href="https://documentation.extremenetworks.com/XIQC/10.06/API/index_gateway_api.html#tag/RoleManager/paths/~1v3~1roles~1%7BroleId%7D/get" target="_blank">Link to Extreme Networks API Documentation</a>

<p>You can do a GET request on it just like in the previous LAB2, but this time the url will look like:</p>
<p><strong>https://&lt;your_own_XIQ-C&gt;:5825/management/v3/roles/&lt;role id&gt;</strong></p>

<p><strong>&lt;role id&gt;:</strong> is the “id” of the role you got during the previous labs</p>




    <script>
        document.addEventListener('DOMContentLoaded', function () {
            var clipboard = new ClipboardJS('.copy-btn');

            clipboard.on('success', function (e) {
                e.clearSelection();
                alert('Code copied to clipboard!');
            });

            clipboard.on('error', function (e) {
                console.error('Copy failed:', e.action);
            });
        });
    </script>
</body>
</html>

