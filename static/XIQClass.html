<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XIQ Lab</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>
    <style>


        pre {
            background-color: #000;
            color: #fff;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            position: relative;
        }
	.copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background-color: #3f3f3f;
            color: #ccc;
            border: none;
            cursor: pointer;
        }
        nav {
            margin: 20px;
        }
        nav ul {
            list-style-type: none;
            padding-left: 0;
        }
        nav ul ul {
            padding-left: 20px;
        }
        nav a {
            text-decoration: none;
            color: blue;
        }
        nav a:hover {
            text-decoration: underline;
        }	

	.print-button {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            background: linear-gradient(to bottom, #f0f0f0, #dcdcdc);
            border: 1px solid #aaa;
            border-radius: 10px;
            box-shadow: 0 4px #999;
            transition: all 0.2s ease;
        }
        .print-button:active {
            box-shadow: 0 2px #666;
            transform: translateY(2px);
        }

        #countdown {
            font-size: 0.8em;
            color: #333;
        }
        #countdown span {
            font-size: 0.8em; /* Smaller size for the digits */
        }

	.popup {
    		position: fixed;
    		top: 50%;
    		left: 50%;
    		transform: translate(-50%, -50%);
    		background-color: #ffffff;
    		padding: 20px;
   	        box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);
	        z-index: 9999;
		}

	.popup-content {
	    text-align: center;
	}

	.popup button {
	    margin: 10px;
	    padding: 8px 20px;
	    font-size: 14px;
	    cursor: pointer;
	}
	


    </style>
</head>
<body>

	<div id="countdown">Your session will expire in <span></span>:<span></span>:<span></span></div>

        <button class="print-button" onclick="printPage()">Print</button> 

	<nav id="toc"></nav>

	<h1> XIQ Lab Environment</h1>

	<p>We can use the Extreme Remote Demo Lab with <strong>read-only</strong> access to complete these labs. You can also use your own ExtremeCloud&trade; IQ credentials to work with your cloud account from the same Jupyter Notebook environment.
	</p>

	<ul>
		<li> Username: <strong>extremeapilabs@gmail.com</strong> </li>
		<li> Password: <strong>Read0nly</strong> </li>

	</ul>

	<h1> Lab 1. API Token </h1>

	<p>At the end of this lab, you will put together a simple Python script to perform an API call against XIQ. You will use an API call to authorize your request and generate an API access token.

We will use Python 3.
	</p>
 <h2>Importing modules</h2>

 <p>
 Python allows you to import functions and variables from modules. This lab will use the requests, json, and pprint modules.</p>
 <p>
 The <strong>requests</strong> module allows you to send HTTP requests using Python. You can send <strong>GET, POST, PUT, PATCH,</strong> and <strong>DELETE</strong> HTTP requests. You can add headers, parameters, and the request body when sending the request. You can also access the data from the response.</p>
 <p>
 The <strong>JSON</strong> module allows you to easily convert back and forth between JSON formatted strings to Python dictionaries.

To import the modules in Python, write ‘import <module_name>’. These 2 modules should be added at the top of your script for this lab.

The <strong>pprint</strong> module provides a method to “pretty-print” Python data structures in a formatted way making the outputs more user friendly to read.

We will start with requests and json and then add pprint later on.
 </p>
   
   
<pre><code id="import">import requests
import json

</code><button class="copy-btn" data-clipboard-target="#import">Copy code</button></pre>

<h2>ExtremeCloud&trade; IQ API endpoint</h2>
<p>
With ExtremeCloud&trade; IQ (XIQ), each API call will be made to the same URL no matter which RDC (Regional Data Center) your VIQ(virtual instance of XIQ) is in. To perform API calls, you will need to get a <strong>JWT token</strong>. In addition to providing authorization, this token provides information about which RDC, which VIQ, who generated the token, when it was generated, and when it expires. So, the information in the token will tell the API gateway to which RDC and VIQ will forward the request.
</p>
<p>All API access is over HTTPS. So, all API calls will start with </p>

<a href="https://api.extremecloudiq.com" target="_blank">https://api.extremecloudiq.com</a>

<p>Create a string variable called <strong>baseurl</strong> in your script and set it to equal this URL:</p>
<p><i>baseurl = "https://api.extremecloudiq.com"</i><p>

<h2>Headers</h2>

<p>
In this lab, we will use the HTTP headers to specify the format you expect the API to respond using and the format in which the data is sent.

We will create a new dictionary variable called <strong>headers</strong>. For now, we will add a key called <strong>‘Accept’</strong>, set the value to <strong>‘application/json’</strong> and create a key called <strong>‘Content-Type’</strong> and set the value to <strong>‘application/json’</strong>.
</p>

<p><i>headers = {'Accept': 'application/json', 'Content-Type': 'application/json'}</i></p>

<pre><code id="headers">import requests
import json

baseurl = "https://api.extremecloudiq.com"

headers = {'Accept': 'application/json', 'Content-Type': 'application/json'}

</code><button class="copy-btn" data-clipboard-target="#headers">Copy code</button></pre>


<h2>Request Body</h2>

<p>When performing POST, PUT, and PATCH HTTP requests, a request body with the information to add or update the endpoint object is typically needed.
</p>
<p>For the /login endpoint, the request body must contain the username and password to generate an API token. The HTTP request will need this in JSON format; we will create this as a Python dictionary, and the requests module will convert it to JSON format.
</p>
<p>Create a dictionary variable called <strong>body</strong>. Add a key called <strong>‘username’</strong> and set it to your XIQ username. Then, add a key called <strong>‘password’</strong> and set it to your XIQ password.
</p>
<p><i>body = {"username": "extremeapilabs@gmail.com", "password": "Read0nly"}</i><p>

<h2>Generating an API token</h2>

<p>A POST API call is used to generate the API token. The endpoint used for this is <strong>/login</strong>. </p>

<p>Please create a new variable called <strong>url</strong> and concatenate our baseurl with <strong>/login</strong>. </p>

<p><i>url = baseurl + '/login'</i></p>

<p>Information can be found for this endpoint on the swagger page. </p>

<a href="https://api.extremecloudiq.com/swagger-ui/index.html#/Authentication/login" target="_blank">https://api.extremecloudiq.com/swagger-ui/index.html#/Authentication/login</a>

<p>Let’s look at how to build this request. </p>

<p>A POST (using requests module) will look similar to the following :</p>
<p><i>response = requests.post(&lt;url&gt;, headers=&lt;request_headers&gt;, json=&lt;request_body&gt;) </i></p>

<p>&lt;url&gt; is the API endpoint we want to use – we defined this a <strong>url</strong><p>

<p>&lt;request_body&gt; is defined in our script as <strong>body</strong>. 

<div style="border: 2px solid #000; padding: 10px; background-color: #f0f0f0; border-radius: 5px;">
	<p style="font-weight: bold; color: #000;">NOTE: The requests module can use json= to convert the Python dictionary to JSON format. If the variable is already in JSON format, you can use data= </p>
</div>

<p>&lt;request_headers&gt; is defined in our script as <strong>headers</strong></p>.

<p>Put this all together and add it to your script.</p>

<p><i>response = requests.post(url,headers=headers,json=body)</i></p>


<pre><code id="response"># Import the requests library for making HTTP requests
import requests

# Import the json library for working with JSON data
import json

# Base URL of the ExtremeCloud IQ API
baseurl = "https://api.extremecloudiq.com"

# Headers to be sent with the HTTP request, specifying that we expect and are sending JSON data
headers = {'Accept': 'application/json', 'Content-Type': 'application/json'}

# Body of the POST request containing the login credentials
body = {
    "username": "extremeapilabs@gmail.com",
    "password": "Read0nly"
}

# Full URL for the login endpoint
url = baseurl + '/login'

# Send a POST request to the login endpoint with the specified headers and body
response = requests.post(url, headers=headers, json=body)

# Print the response from the server (for debugging purposes)
print(response.text)
</code><button class="copy-btn" data-clipboard-target="#response">Copy code</button></pre>

<p>The <strong>response</strong> variable will contain the response object from the HTTP request. This includes the content, encoding, status, etc.</p>


<h2>Status Code</h2>

<p>The first thing we will want to do is check the response's status code. A successful response will have a status code of 2xx. A response that failed due to a client error will have a status code of 4xx. A response with a server-side error will have a status code of 5xx. Here is a table of status codes that can be seen with XIQ.
</p>

<h2> HTTP Status Codes</h2>

<p> The HTTP Status Codes are used to indicate the status of the executed operations.</p>

<h2> Success </h2>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Success</title>
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>

<table>
    <thead>
        <tr>
            <th>HTTP Status Code</th>
            <th>Description</th>
            <th>Use Cases</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>200</td>
            <td>OK</td>
            <td>Standard response for successful HTTP requests.</td>
        </tr>
        <tr>
            <td>201</td>
            <td>Created</td>
            <td>The request has been fulfilled, resulting in the creation of a new resource.</td>
        </tr>
        <tr>
            <td>202</td>
            <td>Accepted</td>
            <td>The request is queued for background processing (async tasks or long-running operations).</td>
        </tr>
        <tr>
            <td>204</td>
            <td>No Content</td>
            <td>The server successfully processed the request and is not returning any content.</td>
        </tr>
    </tbody>
</table>


<h2>Client Error</h2>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Client Error</title>
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>


<table>
    <thead>
        <tr>
            <th>HTTP Status</th>
            <th>Description</th>
            <th>Use Cases</th>
            <th>Client Recovery Policy</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>400</td>
            <td>Bad Request</td>
            <td>The API endpoint exists, but the HTTP request syntax or payload is incorrect, detail will be given in response.</td>
            <td>Do not retry. Fix the request.</td>
        </tr>
        <tr>
            <td>401</td>
            <td>Unauthorized</td>
            <td>The server can be reached and understood the request, but refuses to take any further action, because the client must provide authorization.</td>
            <td>If the client has provided authorization, the server is indicating the provided authorization is unsuitable or invalid. If the user has not supplied authorization information, prompt them for the appropriate credentials. If the user has supplied authorization information, inform them their credentials were rejected and optionally prompt them again.</td>
        </tr>
        <tr>
            <td>403</td>
            <td>Forbidden</td>
            <td>The server can be reached and understood the request, but refuses to take any further action, because it is configured to deny access for some reason to the requested resource by the client.</td>
            <td>Do not retry. Fix the request.</td>
        </tr>
        <tr>
            <td>404</td>
            <td>Not Found</td>
            <td>The API endpoint doesn't exist or resource doesn't exist.</td>
            <td>Do not retry. Fix the request.</td>
        </tr>
        <tr>
            <td>415</td>
            <td>Unsupported Media Type</td>
            <td>The request entity has a media type which the server or resource does not support.</td>
            <td>Do not retry. Fix the request.</td>
        </tr>
        <tr>
            <td>429</td>
            <td>Too Many Requests</td>
            <td>The request entity has a media type which the server or resource does not support.</td>
            <td>Retry after a while.</td>
        </tr>
    </tbody>
</table>

</body>

<h2> Server Error </h2>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Server error</title>
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>


<table>
    <thead>
        <tr>
            <th>HTTP Status</th>
            <th>Description</th>
            <th>Use Cases</th>
            <th>Client Recovery Policy</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>500</td>
            <td>Internal Server Error</td>
            <td>Server side Exception caught, detail will be given in response.</td>
            <td>Ask user to retry later or the client automatically calls retry request.</td>
        </tr>
        <tr>
            <td>503</td>
            <td>Service Unavailable</td>
            <td>The server is temporary unavailable.</td>
            <td>Ask user to retry later or the client automatically calls retry request.</td>
        </tr>
    </tbody>
</table>

</body>

<p>As noted on the swagger page, a successful request for the <strong>/login</strong> endpoint will be given a status code 200. 

With Python, we can check this with an if statement and display a message if the status code is incorrect.
</p>

<p><i>if response.status_code != 200:</i></p>

<p>
Print a statement stating the status code is wrong. You can use the returned status code in the message with str(<i>response.status_code</i>)

You can also get the response content in Unicode with <i>response.text</i>. It can sometimes be useful to see any error messages if the status code is not 200.
</p>

<h2>Response Body</h2>

<p>The requests module includes a function to load the JSON data in the response into a Python object.</p>
<p><i>data = response.json()</i></p>

<p>The response for the <strong>/login</strong> endpoint will be converted into a dictionary object containing 3 keys:<i> access_token, token_type</i>, and <i>expires_in</i>.</p>

<p>The <i>access_token</i> key contains the token that will be used to authenticate API requests. 
The <i>token_type</i> will always be ‘Bearer,’ as XIQ uses only Bearer tokens for authentication. 
The <i>expires_in</i> is the number of seconds the token is valid for. The access token is valid for one day (86400 seconds). 
</p>


<p>For this lab, we are only concerned with the <i>access_token</i>, but note that once the expiration time is up, the token will no longer be valid.</p>

<p><i>token = data['access_token']</i><p>

<p>the variable <i>token</i> should now contain the access token returned from the API call. Print out the token with the following line to see what the token looks like.</p>

<p><i>print(token)</i></p>

<p>The final script should look like this:<p>


<pre><code id="print-token"># Import the requests library for making HTTP requests
import requests

# Import the json library for working with JSON data
import json

# Base URL of the ExtremeCloud IQ API
baseurl = "https://api.extremecloudiq.com"

# Headers to be sent with the HTTP request, specifying that we expect and are sending JSON data
headers = {'Accept': 'application/json', 'Content-Type': 'application/json'}

# Body of the POST request containing the login credentials
body = {
    "username": "extremeapilabs@gmail.com",
    "password": "Read0nly"
}

# Full URL for the login endpoint
url = baseurl + '/login'

# Send a POST request to the login endpoint with the specified headers and body
response = requests.post(url, headers=headers, json=body)

# Check if the request was not successful (status code other than 200)
if response.status_code != 200:
    # Print an error message with the HTTP status code if the request failed
    print(f"Error getting access token - HTTP Status Code: {str(response.status_code)}")

# Parse the response JSON data
data = response.json()

# Extract the access token from the response data
token = data['access_token']

# Print the access token (for debugging purposes or further use)
print(token)


</code><button class="copy-btn" data-clipboard-target="#print-token">Copy code</button></pre>

<p> Copy the code and place it into Jupyter Notebook on the left : you should see the token is collected and printed on the screen.</p>

<h1>Lab 2. Collect Device info from XIQ</h1>

<p>
The script can now collect a Bearer token, which can be used to authenticate the other XIQ API endpoints. We can now build some API calls.

We must add the Bearer token to the headers to authenticate our requests. We already have a header dictionary in our scripts. So, let's add a new key, <strong>‘Authorization,’</strong> and assign the type and token to it. We can concatenate those together in a string.

Open your script, and instead of printing the token, add this line.
</p>

<p><i>headers['Authorization'] = "Bearer " + token</i><p>

<div style="border: 2px solid #000; padding: 10px; background-color: #f0f0f0; border-radius: 5px;">
	<p style="font-weight: bold; color: #000;">NOTE: You could use the ‘token_type’ in the response, but you would need to add a space between that and the token.</p>
	<p><i>headers['Authorization'] = data['token_type'] + " " + token</i><p>
</div>

<p>To get a list of devices, use the endpoint <strong>/devices</strong></p>
<a href="https://api.extremecloudiq.com/swagger-ui/index.html#/Device/listDevices" target="_blank">https://api.extremecloudiq.com/swagger-ui/index.html#/Device/listDevices</a>


<p>
This endpoint has many parameters that can be used. We will examine a few of them and give examples of their use.
Some parameters will have a default value. We will start with the defaults.
</p>

<p>Create a new <strong>url</strong> variable and concatenate the <strong>baseurl</strong> with <strong>/devices</strong></p>

<p><i>url = baseurl + '/devices'</i></p>
<p>
This will override the <strong>url</strong> variable with the new URL. This is fine for our purpose.
Next, we will build a new GET request and assign the response object to the response variable. This also overrides the response variable.</p>

<p><i>response = requests.get(url,headers=headers)</i></p>

<p>Next, print the JSON data from the response. Save and run your script.</p>

<p><i>print(response.json())</i></p>


<pre><code id="print-response">import requests
import json

baseurl = "https://api.extremecloudiq.com"

headers = {'Accept': 'application/json', 'Content-Type': 'application/json'}

body = {
        "username": "extremeapilabs@gmail.com",
        "password": "Read0nly"
        }
url = baseurl + '/login'

response = requests.post(url,headers=headers,json=body)

if response.status_code != 200:
        print(f"Error getting access token - HTTP Status Code: {str(response.status_code)}")


data = response.json()
token = data['access_token']

headers['Authorization'] = "Bearer " + token

url = baseurl + '/devices'
response = requests.get(url,headers=headers)

print(response.json())



</code><button class="copy-btn" data-clipboard-target="#print-response">Copy code</button></pre>


<p> 
What do you think? It’s not very readable. Like a JSON string, printing a Python dictionary displays the entire dictionary as a string.

We can make this more user-readable with the <strong>pprint</strong> (Pretty Print) module. We only need a <strong>pprint</strong> function of that module and we will create an alias for our script.

If we just imported the pprint module, every time we wanted to use the pprint function, we would have to type <strong>pprint.pprint</strong>(string)

So, to import just the function, we can add <strong>‘from pprint import pprint’</strong>. Then, to create an alias or rename the module for our script we can add as<strong>’pp’</strong>. This would allow us to enter <strong>pp</strong>(string) in our script to leverage the pretty print function.

At the top of your script, below the import json line, enter this:
</p>
<p><i>from pprint import pprint as pp</i></p>

<p>Then change the print(response.json()) line to pp(response.json()), then save and run the script.</p>

<pre><code id="pp">import requests
import json
from pprint import pprint as pp

baseurl = "https://api.extremecloudiq.com"

headers = {'Accept': 'application/json', 'Content-Type': 'application/json'}

body = {
        "username": "extremeapilabs@gmail.com",
        "password": "Read0nly"
        }
url = baseurl + '/login'

response = requests.post(url,headers=headers,json=body)

if response.status_code != 200:
        print(f"Error getting access token - HTTP Status Code: {str(response.status_code)}")


data = response.json()
token = data['access_token']

headers['Authorization'] = "Bearer " + token

url = baseurl + '/devices'
response = requests.get(url,headers=headers)

pp(response.json())
</code><button class="copy-btn" data-clipboard-target="#pp">Copy code</button></pre>


<p> 
Now, look at the printed response. The dictionary has five keys: page, count, total_pages, total_count, and data.
Most XIQ API calls that list things (devices, clients, users, network policies, etc.) will use pagination. These calls would all include the same 5 keys.
</p>

<p>
<strong>data</strong> – This would be a list of data returned for the elements included on the page

Pagination info:

<strong>page</strong> – The current page number
<strong>count</strong> - The element count of the current page
<strong>total_pages</strong> – The total pages based on the request page size
<strong>total_count</strong> – The total element count
</p>

<h2>Parameters</h2>

<h3>Page size</h3>

<p> 
For XIQ API calls that use pagination, XIQ defaults the page size to 10 elements. By adding a parameter to the request, we can adjust it up to 100. 

Add space before the line with the request to get devices but after the <strong>url</strong> line. In this space, add a new dictionary called <strong>params</strong>. Add a <strong>page</strong> key and set it to <strong>1</strong>, and a <strong>limit</strong> key and set it to <strong>100</strong>. 
</p>

<p><i>params = {"page":1,"limit":100}</i></p>

<p>
You will also need to add the params dictionary to the <strong>request.get</strong> function arguments.
</p>

<p><i>response = requests.get(url,headers=headers,params=params) </i></p>

<p>Now, when you run the script, you should see that ‘count’ is set to 100.</p>

<pre><code id="params">import requests
import json
from pprint import pprint as pp

baseurl = "https://api.extremecloudiq.com"

headers = {'Accept': 'application/json', 'Content-Type': 'application/json'}

body = {
        "username": "extremeapilabs@gmail.com",
        "password": "Read0nly"
        }
url = baseurl + '/login'

response = requests.post(url,headers=headers,json=body)

if response.status_code != 200:
        print(f"Error getting access token - HTTP Status Code: {str(response.status_code)}")


data = response.json()
token = data['access_token']

headers['Authorization'] = "Bearer " + token

url = baseurl + '/devices'

params = {
	  "page": 1,
	  "limit": 100
	 }

response = requests.get(url,headers=headers,params=params)

pp(response.json())

</code><button class="copy-btn" data-clipboard-target="#params">Copy code</button></pre>

<h3>Views</h3>
<p>
The /devices endpoint has a parameter named <strong>views</strong>, which changes which fields will be returned for each device. By default, this is set to basic. You can see which fields are included in each view by looking at the view’s parameter in the documentation.
</p>

<a href="https://extremecloudiq.com/api-docs/api-reference.html#_list_devices" target="_blank">https://extremecloudiq.com/api-docs/api-reference.html#_list_devices</a>

<p>
The full view contains information like the network policy name, network policy ID, and lldp_cdp_info that aren’t included in other views.

Add a key to the <strong>params</strong> dictionary called <strong>views</strong> and set it to <strong>“Full”</strong>.

</p>

<p><i>params = {“page”:1,”limit”:100,”views”:”Full”}</i></p>


<pre><code id="views">import requests
import json
from pprint import pprint as pp

baseurl = "https://api.extremecloudiq.com"

headers = {'Accept': 'application/json', 'Content-Type': 'application/json'}

body = {
        "username": "extremeapilabs@gmail.com",
        "password": "Read0nly"
        }
url = baseurl + '/login'

response = requests.post(url,headers=headers,json=body)

if response.status_code != 200:
        print(f"Error getting access token - HTTP Status Code: {str(response.status_code)}")


data = response.json()
token = data['access_token']

headers['Authorization'] = "Bearer " + token

url = baseurl + '/devices'

params = {
          "page": 1,
          "limit": 100,
	  "views": "Full"
         }
response = requests.get(url,headers=headers,params=params)

pp(response.json())

</code><button class="copy-btn" data-clipboard-target="#views">Copy code</button></pre>


<h1>Lab 3. Collecting all pages of devices</h1>

<p>
So, we have set the limit to 100 devices, but what if there are more? Or what if you are collecting a different element with more than 1 page?

This is where we can use the pagination information within a Python loop.

In your script, delete the params variable, the line with the request.get, and the pp lines.
Before we create the loop, let's create 2 variables. Below the <strong>url</strong> = baseurl + “/devices” line, create a variable <strong>page</strong>, set it to <strong>1</strong>, and create <strong>pageCount</strong> and set it to <strong>1</strong>.

Also, add an empty list named <strong>devices</strong>. Here, we will store the data portion of the requests as we go through each page.
</p>

<p><i>page=1</i></p>
<p><i>pageCount = 1</i></p>
<p><i>devices=[]</i></p>

<p>
We will create a while loop to loop through the API call <strong>while page &lt= pageCount</strong>. We will use the pagination info to update their variables or we will be stuck in an infinite loop!

Add back the params dictionary inside the "while loop", but have the <strong>page</strong> key set to <strong>page</strong> variable.
</p>

<p><i>params = {"page":page,"limit":100,"views":"Full"} </i></p>

<p>Add back the request returning the response object</p>

<p><i>response = requests.get(url,headers=headers,params=params) </i></p>

<p>use the json() function to convert the response.</p>
<p><i>data = response.json()</i></p>

<p>We will add the response data to the device list. We want to ensure we keep any data already in the devices list and add the raw data to it.</p>
<p><i>devices = devices + data['data']</i></p>

<p>Once we have collected the data for this loop instance, we need to update the <strong>page</strong> and <strong>pageCount</strong> variables. Set the page to <strong>response[‘page’] + 1</strong> (to collect the next page). Then set <strong>pageCount</strong> to <strong>response[‘total_pages’]</strong>.</p>

<p><i>page = data['page'] + 1</i></p>
<p><i>pageCount = data['total_page']</i></p>

<p>Add a pretty print and print the devices list outside of the while loop.</p>
<p><i>pp(devices)</i></p>

<p>Let’s add a print statement with the number of devices in the list.</p>

<p><i>print(f"There are {len(devices)} devices in my list")</i></p>


<pre><code id="collect">import requests
import json
from pprint import pprint as pp

baseurl = "https://api.extremecloudiq.com"

headers = {'Accept': 'application/json', 'Content-Type': 'application/json'}

body = {
        "username": "extremeapilabs@gmail.com",
        "password": "Read0nly"
        }
url = baseurl + '/login'

response = requests.post(url,headers=headers,json=body)

if response.status_code != 200:
        print(f"Error getting access token - HTTP Status Code: {str(response.status_code)}")


data = response.json()
token = data['access_token']

headers['Authorization'] = "Bearer " + token

url = baseurl + '/devices'

page = 1
pageCount = 1
devices = []

while page <= pageCount:
	params = {
        	  "page": page,
         	  "limit": 100,
          	  "views": "Full"
         }


	response = requests.get(url, headers=headers, params=params)
	data = response.json()
	devices = devices + data['data']
	page = page + 1
	pageCount = data['total_pages']

	pp(devices)
	print(f"There are {len(devices)} devices in my list")	   

</code><button class="copy-btn" data-clipboard-target="#collect">Copy code</button></pre>

<p> After running the script,you should see a list of devices with all their information and a string printed with the number of devices.</p>


<h1>Lab 4 (optional) - Switch between Granted Access VIQs </h1>

<p>
If your XIQ account has been granted access to other VIQs, you can use additional API calls to generate a token for one of those VIQs. Following the Lab 1 guide, you will use the /login endpoint to generate a token. This will be to access information about the VIQ the user generating the token belongs to. This will be the first step even when you want to collect data from a VIQ the user has been granted access to.

The script can now collect a Bearer token, which can be used to authenticate the other XIQ API endpoints. We can now build some API calls.

We must add the Bearer token to the headers to authenticate our requests. We already have a header dictionary in our scripts. So, let's add a new key, <strong>‘Authorization,’</strong> and assign the type and token to it. We can concatenate those together in a string.

Open your script, and instead of printing the token, add this line.

</p>

<p><i>headers['Authorization'] = "Bearer " + token</i></p>

<div style="border: 2px solid #000; padding: 10px; background-color: #f0f0f0; border-radius: 5px;">
        <p style="font-weight: bold; color: #000;">NOTE: The requests module can use json= to convert the Python dictionary to JSON format. If the variable is already in JSON format, you can use data= </p>
</div>

<p>First, we will need to get a list of accounts that have been granted external access. The /account/external endpoint will be used for this.</p>

<a href="https://api.extremecloudiq.com/swagger-ui/index.html#/Account/listExternalAccounts" target="_blank">https://api.extremecloudiq.com/swagger-ui/index.html#/Account/listExternalAccounts</a>

<p>Create a new <strong>url</strong> variable and concatenate the <strong>baseurl</strong> with <strong>/account/external</strong></p>

<p><i>url = baseurl + '/account/external’</i></p>

<p>
This will override the <strong>url</strong> variable with the new URL. This is fine for our purpose.
Next, we will build a new GET request and assign the response object to the response variable. This also overrides the response variable.
<p>
<p><i>response = requests.get(url,headers=headers)</i></p>

<p>Next, print the JSON data from the response. Save and run your script.</p>
<p><i>print(response.json())</i><p>


<pre><code id="optional">import requests
import json

baseurl = "https://api.extremecloudiq.com"

headers = {'Accept': 'application/json', 'Content-Type': 'application/json'}

body = {
	"username": "extremeapilabs@gmail.com",
	"password": "Read0nly"
	}
url = baseurl + '/login'

response = requests.post(url,headers=headers,json=body)

if response.status_code != 200:
	print(f"Error getting access token - HTTP Status Code: {str(response.status_code)}")

data = response.json()
token = data['access_token']

headers['Authorization'] = "Bearer " + token

url = baseurl + '/account/external'

response = requests.get(url, headers=headers)

print(response.json())



</code><button class="copy-btn" data-clipboard-target="#optional">Copy code</button></pre>


<p>
With the ID of the VIQ you want to switch to, you can use the <strong>/account/:switch?id={{viq_id}}</strong> endpoint.

Using the same process, we will create the URL, perform the POST call, and then update the header authorization with the new token.
<p/>

<p><i>url = baseurl + ‘/account/:switch?id={{viq_id}}</i><p>

<p>replace {{viq_id}} with the id returned for the VIQ</p>

<p><i>response = requests.post(url,headers=headers)</i></p>
<p><i>data = response.json()</i></p>
<p><i>headers[‘Authorization’] = ‘Bearer ‘ + data[‘access_token’]</i></p>



<pre><code id="optional2">import requests
import json
baseurl = "https://api.extremecloudiq.com"

headers = {'Accept': 'application/json', 'Content-Type': 'application/json'}
body = {
    "username": "extremeapilabs@gmail.com", 
    "password": "Read0nly"  
}


# Login URL
url = baseurl + '/login'
# Login Request
response = requests.post(url, headers=headers, json=body)


# Check if login was successful
if response.status_code != 200:
    print(f"Error getting access token - HTTP Status Code: {str(response.status_code)}")
    exit()


# Extract token from response
data = response.json()
token = data.get('access_token')
if not token:
    print("Error: No access token found in the response")
    exit()


# Update headers with the Authorization token
headers['Authorization'] = 'Bearer ' + token


# GET request to /account/external
url = baseurl + '/account/external'
response = requests.get(url, headers=headers)
if response.status_code == 200:
    external_data = response.json()
    print("External Account Data:")
    print(json.dumps(external_data, indent=4))
else:
    print(f"Error fetching external account data - HTTP Status Code: {response.status_code}")

# GET request to /account/:switch?id={VIQ_ID} 

url = f"{baseurl}/account/:switch?id=398641"  #Replace VIQ ID as needed
response = requests.post(url, headers=headers)
if response.status_code == 200:
    switch_data = response.json()
    print("Switch Data:")
    print(json.dumps(switch_data, indent=4))
else:
    print(f"Error fetching switch data - HTTP Status Code: {response.status_code}")
headers['Authorization'] = 'Bearer ' + data['access_token']


# Print headers for verification
print("Headers with Authorization token:")
print(headers)



</code><button class="copy-btn" data-clipboard-target="#optional2">Copy code</button></pre>



    <script>
        document.addEventListener('DOMContentLoaded', function () {
            var clipboard = new ClipboardJS('.copy-btn');

            clipboard.on('success', function (e) {
                e.clearSelection();
                alert('Code copied to clipboard!');
            });

            clipboard.on('error', function (e) {
                console.error('Copy failed:', e.action);
            });
        });
    </script>

    <script type="text/javascript">
        function printPage() {
            window.print();
        }
    </script>





    <script>
document.addEventListener("DOMContentLoaded", function() {
    // Select the container for the ToC
    const toc = document.getElementById("toc");

    // Create a list to hold the ToC entries
    const tocList = document.createElement("ul");

    // Get all the headings (h1, h2, h3)
    const headings = document.querySelectorAll("h1, h2, h3");
    headings.forEach((heading, index) => {
        // Create a unique ID for each heading if it doesn't have one
        if (!heading.id) {
            heading.id = `heading-${index}`;
        }

        // Create the list item and link for the ToC
        const listItem = document.createElement("li");
        const link = document.createElement("a");
        link.href = `#${heading.id}`;
        link.textContent = heading.textContent;

        // Nest the list items according to heading level
        if (heading.tagName === "H2") {
            let parentItem = tocList.lastElementChild;
            if (!parentItem.querySelector("ul")) {
                const subList = document.createElement("ul");
                parentItem.appendChild(subList);
            }
            parentItem.querySelector("ul").appendChild(listItem);
        } else if (heading.tagName === "H3") {
            let parentItem = tocList.lastElementChild.querySelector("ul").lastElementChild;
            if (!parentItem.querySelector("ul")) {
                const subSubList = document.createElement("ul");
                parentItem.appendChild(subSubList);
            }
            parentItem.querySelector("ul").appendChild(listItem);
        } else {
            tocList.appendChild(listItem);
        }

        listItem.appendChild(link);
    });

    // Add the ToC list to the container
    toc.appendChild(tocList);
});
</script>

    <script>
function updateCountdown() {
    const now = new Date(); // Current time in UTC since system's date is in UTC
    const nextSessionEnd = new Date(now);

    nextSessionEnd.setUTCHours(4, 0, 0, 0); // Set target time to 4 AM UTC

    // If current time is past 4 AM UTC, set countdown to next day's 4 AM UTC
    if (now.getUTCHours() >= 4) {
        nextSessionEnd.setUTCDate(nextSessionEnd.getUTCDate() + 1);
    }

    const timeRemaining = nextSessionEnd - now;

    const hours = Math.floor((timeRemaining / (1000 * 60 * 60)) % 24);
    const minutes = Math.floor((timeRemaining / (1000 * 60)) % 60);
    const seconds = Math.floor((timeRemaining / 1000) % 60);

    // Update countdown display
    document.getElementById("countdown").getElementsByTagName('span')[0].textContent = `${hours.toString().padStart(2, '0')}`;
    document.getElementById("countdown").getElementsByTagName('span')[1].textContent = `${minutes.toString().padStart(2, '0')}`;
    document.getElementById("countdown").getElementsByTagName('span')[2].textContent = `${seconds.toString().padStart(2, '0')}`;

    // Check if less than 1 minute left
    if (timeRemaining < 60000) { // 60,000 milliseconds = 1 minute
        setTimeout(showSessionExpiredPopup, timeRemaining - 60000); // Show popup 1 minute before session expires
    }
}

function showSessionExpiredPopup() {
    // Create popup
    const popup = document.createElement('div');
    popup.className = 'popup';
    popup.innerHTML = `
        <div class="popup-content">
            <p>Your session expired. Please refresh the page.</p>
            <button onclick="refreshPage()">Refresh Page</button>
            <button onclick="cancelPopup()">Cancel</button>
        </div>
    `;
    document.body.appendChild(popup);
}

function refreshPage() {
    parent.location.reload();
}

function cancelPopup() {
    const popup = document.querySelector('.popup');
    if (popup) {
        popup.remove();
    }
}

// Update the countdown every second
setInterval(updateCountdown, 1000);
// Initial call to display immediately
updateCountdown();
	    
    </script>


</body>
</html>

